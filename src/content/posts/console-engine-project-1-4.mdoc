---
title: 4일차 개발 일지
pubDate: 2026-02-09T19:08:00.000Z
category: '콘솔 엔진 프로젝트 #1'
tags:
  - console-engine-project-1
---
## 성과

### 1. 2x2 멀티라인 렌더링 시스템

![](/images/posts/console-engine-project-1-4/2grid.png)

- **타일 렌더링**: 각 타일을 2x2 문자 블록으로 표현
  - Tile 클래스에 `displayStr[4][8]` 추가: 한 타일을 2x2 문자 블록으로 표현 (4개 셀: 좌상, 우상, 좌하, 우하)
  - 평지: 점 4개 (`.`)
  - 숲: 스페이드 4개 (`♠`)
  - 산: 삼각형과 블록 (`/\`, `▓`)
  - 성: 박스 문자 (`╔╗╚╝`)
  - 마을: 지붕과 벽 (`/\`, `▄`)
  - 물: 물결 4개 (`≈`)
  - 벽: 블록 4개 (`█`)
- **좌표 변환**: 그리드 좌표 `(x, y)` → 화면 좌표 `(x*2+1, y*2+1)`
  - 그리드의 (0, 0)은 화면의 (1, 1)에 그려짐
  - 그리드의 (1, 0)은 화면의 (3, 1)에 그려짐
  - 2배로 확대하고, UI 여백 1칸을 위해 +1을 함
- **마우스 클릭 역변환**: `gridX = (mousePos.x - 1) / 2`, `gridY = (mousePos.y - 1) / 2`
  - 화면 좌표를 그리드 좌표로 바꿀 때, 2x2 배율과 UI 여백을 고려

### 2. 렌더링 우선순위 시스템 정립

- **sortingOrder 계층**: 지형(7) < 아이템(8) < 하이라이트(9) < 유닛(10)
  - 숫자가 클수록 위에 그려짐
  - 같은 위치에 여러 게 있을 때, 우선순위가 높은 것만 보임
- 같은 위치에 여러 객체가 있을 때 우선순위 높은 것만 표시
- 지형이 유닛에 가려지지 않도록 설계
  - 유닛이 항상 최상위에 보이도록 함
- **UI 레이아웃**: 2x2 적용 후 스탯 패널·툴팁 위치 재계산
  - 스탯 패널: `panelX = grid->GetWidth() * 2 + 6` (맵 너비 * 2 + 6칸 여백)
  - 맵과 UI가 겹치지 않도록 설정

### 3. 전투 시스템 구현

- **PerformCombat() 함수**: 두 유닛이 싸우는 함수
  - 데미지 계산: `max(0, 공격자 STR - 방어자 DEF)`
    - 공격자의 공격력에서 방어자의 방어력을 뺀 값
    - 음수가 되면 0으로 처리 (최소 데미지는 0)
  - SPD 우위 시 2회 타격 로직
    - 공격자의 속도가 방어자의 속도보다 크면 2번 때림
    - 아니면 1번만 때림
  - `TakeDamage()` 함수로 피격 처리
    - 유닛의 체력을 깎음
  - 전투 불능 시 타일·리스트에서 제거 후 `Destroy()` 호출
    - 체력이 0 이하가 되면 게임에서 제거됨
- **인접 공격만 지원**: 원거리/마법 미구현 (간소화)
  - 바로 옆 타일에 있는 적만 공격할 수 있음
- **전투 로그**: 이벤트 로그에 세그먼트별 색상으로 기록
  - "아군 유닛명이 적 유닛명에게 데미지 X를 입혔습니다" 같은 형식
  - 유닛명은 진영별 색상으로 표시

### 4. 적 AI 시스템

- **EnemyAI 클래스**: 적 유닛이 어떻게 행동할지 결정하는 클래스
  - `RunAI()` 함수로 적 행동 결정
  - **인접 시 공격**: 플레이어 유닛에 4방 인접해 있으면 공격 후 턴 종료
    - 바로 옆에 있으면 무조건 공격함
  - **비인접 시 이동**: 이동 범위 내 플레이어 인접 타일 중 도달 가능한 타일을 목표로 A* 경로 탐색
    - 멀리 있으면 플레이어에게 다가감
    - 플레이어 바로 옆 타일 중 하나를 목표로 정하고, 그곳으로 이동함
  - 이동 시 `onEnemyMoved` 콜백으로 이벤트 로그 전달
    - 적이 이동했다는 로그를 남김

### 5. 턴 시스템 구현

- **플레이어 턴 ↔ 적 턴 전환**:
  - SPACE 키로 수동 턴 종료
    - 아직 행동하지 않은 유닛이 있어도 턴을 넘길 수 있음
  - 아군 전원 행동 완료 시 자동 턴 종료
    - 모든 아군 유닛이 Done 상태가 되면 자동으로 적 턴으로 넘어감
  - 적 전원 행동 완료 시 자동 턴 종료
    - 모든 적 유닛이 행동을 마치면 자동으로 플레이어 턴으로 넘어감
- **유닛 상태 관리**:
  - `ResetTurn()` 함수로 Done 상태를 Idle로 초기화
    - 새 턴이 시작되면 모든 유닛의 상태를 초기화함
  - 턴 전환 시 모든 유닛 상태 초기화

### 6. 게임 종료 조건 시스템

- **CheckEndConditions() 함수**: 게임이 끝났는지 확인하는 함수
  - 아군 패배: `playerUnits`가 비었거나, 살아 있는 아군 중 로드(UnitClass::Lord)가 없음
    - 아군이 모두 죽었거나, 주인공이 죽으면 패배
  - 적군 패배: `enemyUnits`가 비어 있음
    - 적이 모두 죽으면 승리
- **TriggerGameOver() 함수**: 게임 종료 처리 함수
  - `gameOver` 플래그 설정
  - 모든 유닛 제거·파괴
    - 게임이 끝나면 모든 유닛을 삭제함
  - 벽을 제외한 맵을 평지로 초기화
    - 맵을 깨끗하게 정리함
  - 선택 포인터들(`selectedUnit`, `unitPendingAttack` 등)을 `nullptr`로 설정
    - 더 이상 사용하지 않는 포인터들을 초기화함
- **게임 종료 후 처리**:
  - Tick에서는 `if (gameOver) return;`으로 로직 생략
    - 게임이 끝나면 더 이상 게임 로직을 실행하지 않음
  - Draw에서는 맵 중앙에 "PLAYER VICTORY" / "ENEMY VICTORY"를 진영 색상으로 표시
    - 승리 메시지만 보여줌

### 7. 전투 관련 입력 처리

- **인접 적 클릭**: 즉시 `PerformCombat()` 호출
  - 바로 옆에 있는 적을 클릭하면 바로 공격함
- **비인접 적 클릭**: 이동 가능한 적 인접 타일로 경로 이동 후 `ProcessPendingAttackAfterMove()`에서 공격
  - 멀리 있는 적을 클릭하면, 그 적 옆으로 이동한 다음 공격함

## 난관

### 1. 게임 종료 시 크래시 문제

- **문제**: `TriggerGameOver()` 호출 후 프로그램 크래시
  - 게임이 끝날 때 프로그램이 죽어버림
- **원인**:
  - `TriggerGameOver()`에서 포인터를 `nullptr`로 만든 뒤, 호출한 쪽에서 여전히 그 포인터를 사용
  - 예: `ProcessPendingAttackAfterMove()`에서 `PerformCombat()` 호출 후 `unitPendingAttack->EndTurn()` 호출 시도
    - `PerformCombat()` 안에서 게임이 끝나서 `unitPendingAttack`이 nullptr가 되었는데, 그 다음 줄에서 `unitPendingAttack->EndTurn()`을 호출하려고 해서 크래시
- **해결**:
  - `PerformCombat()` 호출 직후 `if (gameOver) return;` 체크 추가
    - 게임이 끝났는지 확인하고, 끝났으면 더 이상 진행하지 않음
  - `ProcessPendingAttackAfterMove()`와 `OnMouseClick()`의 인접 적 공격 분기에 적용
  - Draw에서도 `gameOver`일 때 유닛 렌더링 생략
    - 게임이 끝났으면 유닛을 그리지 않음

### 2. 적 AI 설계의 복잡성

- **문제**: 초기에는 복잡한 AI 로직을 고려했으나 구현 난이도 높음
  - 처음에는 다양한 상황에 맞춰 행동하도록 만들려고 했음
- **난관**: 다양한 상황별 행동 패턴 설계 필요
  - 상황이 많아질수록 복잡해짐
- **해결**: "인접하면 공격, 아니면 이동"으로 단순화하여 의도를 명확히 함
  - 간단하지만 효과적인 방식으로 바꿈
- **효과**: 구현이 간단해지고 버그 가능성 감소
  - 단순한 로직이니까 버그가 적고, 이해하기도 쉬움
- **느낀 점**: 적 AI를 "어떻게 설계해야 할지"부터 고민이 많았음. 상황별로 세분화하면 복잡해지고, 너무 단순하면 재미없을까 봐 걱정했는데, 일단 "인접하면 공격, 아니면 이동"으로 고정하고 나니 구현과 설명이 모두 수월해져서, 발표에서 "적 AI를 이렇게 단순화했다"고 말하기 좋은 결정이었음.

### 3. 턴이 입력 없이 자동 진행되는 문제

- **문제**: `HandleInput` 안에 조건 없는 블록에서 `isPlayerTurn`을 매 프레임 토글
  - 의도하지 않은 코드가 있어서 턴이 자동으로 바뀜
- **난관**: 의도하지 않은 턴 전환 발생
  - 플레이어가 아무것도 안 해도 턴이 넘어감
- **해결**: 해당 블록 제거, SPACE 키 입력 시에만 턴 전환하도록 수정
  - 명시적으로 SPACE를 눌러야만 턴이 넘어가도록 함

### 4. 전투 후 유닛 상태 관리

- **문제**: 전투 후 유닛의 턴 종료 시점 결정
  - 전투가 끝나면 유닛의 턴을 종료해야 하는데, 언제 종료할지가 애매함
- **난관**: 이동 후 공격 vs 인접 공격의 상태 전환 차이
  - 이동해서 공격하는 경우와 바로 공격하는 경우가 다름
- **해결**:
  - 이동 후 공격: `ProcessPendingAttackAfterMove()`에서 `EndTurn()` 호출
    - 이동이 끝나고 공격한 다음 턴 종료
  - 인접 공격: `OnMouseClick()`에서 `EndTurn()` 호출
    - 바로 공격한 다음 턴 종료
  - 게임 종료 시에는 `EndTurn()` 호출 생략
    - 게임이 끝났으면 턴 종료할 필요가 없음

### 5. 지형 vs 하이라이트 sorting order 문제

- **문제**: 이동 범위 하이라이트가 지형에 가려지는 경우
  - 이동 가능한 곳을 표시하는 점이 지형에 가려져서 안 보임
- **난관**: 한 타일에 문자 하나만 그려지는 콘솔의 제약
  - 콘솔은 한 칸에 하나의 문자만 표시할 수 있음
- **해결**: 지형(7) < 하이라이트(9) < 유닛(10) 순서로 설정하여 하이라이트가 지형 위에 표시되도록 함
  - 하이라이트의 우선순위를 지형보다 높게 설정함
- **개인적으로 어려웠던 점**: 한 타일에 문자 하나만 그려지는 콘솔 제약 때문에, 지형(terrain)과 이동 범위 하이라이트(highlight) 중 무엇을 위에 둘지 결정하기가 쉽지 않았음. 유저가 "이동 가능한 곳"을 잘 보이게 하려면 하이라이트가 지형 위에 있어야 하는데, 그걸 숫자 하나로 표현해야 해서 고민이 많았음.

### 6. 유닛 렌더링과 좌표 변환 (2x2 적용)

- **문제**: 유닛 렌더링이 `Actor::position` 기준으로만 되어 있고, 이동 시 `gridPosition`만 바뀜
  - Actor에는 position이 있고, Unit에는 gridPosition이 있음
  - 렌더링은 여전히 position을 보고 있어서 2x2 적용 후 어긋남
- **해결**:
  - `Unit::Draw()`는 `gridPosition`을 2x2 화면 좌표로 변환해 그리기
  - `AddUnit`/`BeginPlay`에서 `SetPosition` 호출 제거, `gridPosition`만 사용하도록 통일
- **좌표 변환 오류**: 마우스 클릭 좌표를 그리드 좌표로 변환할 때 `gridX = (mousePos.x - 1) / 2`, `gridY = (mousePos.y - 1) / 2` 공식 사용 (UI 여백 1, 2x2 배율 반영)

## 요약

4일차는 **2x2 멀티라인 렌더링·좌표 변환·렌더링 우선순위 정립**과 **전투 시스템, AI, 턴 시스템**을 구현하는 데 집중했음. 2x2 멀티라인으로 타일·유닛을 시각적으로 구분하고, 그리드↔화면 좌표 변환과 렌더링 우선순위(sortingOrder)를 정립했음. 이어서 전투 데미지 계산과 SPD 기반 2회 타격 로직을 완성했고, 적 AI를 단순하지만 효과적인 방식으로 구현했음. 특히 게임 종료 시 크래시 문제를 해결하며, 포인터 관리와 상태 전환의 중요성을 깨달았음. 턴 시스템도 완성하여 게임의 핵심 루프를 마무리했음. 이 시점에서 게임의 기본적인 플레이 사이클이 완성되었음.

## 느낀 점

전투·턴·종료 조건이 이어지니까 "한 판이 돌아가는 게임"으로 느껴지기 시작했음. 대신 게임 종료 직후 크래시가 나서, "끝났는데 왜 터지지?" 하면서 원인 찾는 데 시간을 썼음. 포인터를 null로 만든 뒤에도 그 포인터를 쓰는 코드 경로가 남아 있을 수 있다는 걸 몸으로 익힌 날이었음.
