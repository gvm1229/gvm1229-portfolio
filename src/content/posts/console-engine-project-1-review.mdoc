---
title: 프로젝트 회고록
pubDate: 2026-02-11T17:10:00.000Z
category: '콘솔 엔진 프로젝트 #1'
tags:
  - console-engine-project-1
---
## 시연 영상

{% youtube id="Qr6olpAJfvk" /%}

## 잘한 부분과 그 이유

### 1. 문서화 (DEBUG.md, Contexts.md, GameFlow.md 등)

- **잘한 점**: 개발 과정에서 발생한 버그와 해결 방법을 상세히 문서화
- **이유**:
  - 같은 문제를 다시 겪었을 때 빠르게 해결 가능
    - 나중에 비슷한 문제가 생겨도 문서를 보면 바로 해결할 수 있음
  - 프로젝트 구조와 로직을 명확히 정리하여 유지보수 용이
    - 코드만 봐서는 이해하기 어려운 부분을 문서로 설명해둠
  - 초보자도 이해할 수 있도록 단계별 설명 제공
    - 나중에 다시 봐도 쉽게 이해할 수 있도록 자세히 설명함
- **효과**: 프로젝트 후반부에서 이전에 해결한 문제를 빠르게 참고할 수 있었음
  - 특히 댕글링 포인터 문제를 여러 번 겪었는데, 문서를 보면서 빠르게 해결했음

### 2. 단계별 검증 및 디버깅

- **잘한 점**: A* 알고리즘 구현 시 단계별로 검증하며 문제를 해결
- **이유**:
  - 복잡한 알고리즘을 한 번에 구현하려 하면 디버깅이 어려움
    - A*는 여러 부분이 얽혀있어서 한 번에 다 고치려고 하면 어디가 문제인지 찾기 어려움
  - 각 부분을 독립적으로 검증하여 문제 지점을 명확히 파악
    - 휴리스틱 계산, 닫힌 리스트 관리, 경로 역추적 등을 하나씩 확인함
- **효과**: A* 알고리즘의 휴리스틱, 닫힌 리스트, 경로 역추적 문제를 체계적으로 해결
  - 한 번에 다 고치려고 하지 않고 하나씩 확인하면서 수정해서, 문제를 빠르게 해결했음

### 3. 간소화된 설계 결정

- **잘한 점**: 전투 전용 UI 화면을 포기하고 맵 위에서 로그로만 전투 결과 표시
- **이유**:
  - 초반 계획이 너무 커서 시간 부족
    - 원작처럼 별도의 전투 화면을 만들려고 했는데 시간이 부족했음
  - 핵심 기능(맵, 이동, 전투, 종료 조건)에 집중
    - 게임이 돌아가는데 꼭 필요한 기능에만 집중함
  - 로그 시스템으로 충분히 정보 전달 가능
    - 전투 결과를 로그로 보여주는 것만으로도 플레이어가 이해할 수 있음
- **효과**: 프로젝트를 완성도 있게 마무리할 수 있었음
  - 모든 기능을 다 구현하지 못했지만, 핵심 기능은 완성해서 게임으로서 동작함

### 4. 렌더링 시스템의 우선순위 설계

- **잘한 점**: sortingOrder 시스템으로 지형(7) < 하이라이트(9) < 유닛(10) 계층 구조 확립
- **이유**:
  - 콘솔의 한 타일에 문자 하나만 그려지는 제약을 고려
    - 콘솔은 한 칸에 하나의 문자만 표시할 수 있어서, 여러 게 겹치면 하나만 보임
  - 시각적 계층 구조를 명확히 하여 사용자 경험 개선
    - 어떤 게 위에 올지 미리 정해두면, 사용자가 보기 좋은 화면이 나옴
- **효과**: 이동 범위 하이라이트가 지형에 가려지지 않고, 유닛이 항상 최상위에 표시됨
  - 사용자가 중요한 정보(유닛 위치, 이동 가능 범위)를 쉽게 볼 수 있음
- **아쉬웠던 점**: terrain(지형)과 highlight(이동 범위 하이라이트)의 sorting order를 어떻게 둘지 결정하기가 어려웠음. 한 타일에 렌더할 수 있는 것이 하나뿐이라, 유저가 겪을 헷갈림을 최소화하려다 보니 우선순위 숫자 하나를 정하는 데도 고민이 많았음.

### 5. 메모리 수명 관리 학습

- **잘한 점**: 댕글링 포인터 문제를 여러 번 경험하며 메모리 수명 관리의 중요성 이해
- **이유**:
  - Submit 시점과 실제 그리기 시점의 분리로 인한 복잡성 인식
    - 렌더러는 포인터만 저장하고 나중에 그리는데, 그 사이에 메모리가 사라질 수 있음
  - 멤버 변수나 벡터 등 오래 사는 저장소 활용
    - 임시 변수 대신 객체의 멤버 변수나 벡터에 저장해두면 오래 살아있음
- **효과**: 이후 유사한 문제를 빠르게 해결할 수 있는 경험 축적
  - 같은 문제를 여러 번 겪으면서 패턴을 이해하게 되어, 나중에는 빠르게 해결할 수 있었음

## 부족한 점과 그 이유, 해결 방법

### 1. 초기 계획의 과도한 범위

- **부족한 점**: 전투 전용 UI 화면, 원거리 유닛, 무기 시스템 등 계획이 너무 큼
- **이유**:
  - 원작의 기능을 모두 구현하려는 욕심
    - Fire Emblem 원작에 있는 기능을 다 넣으려고 했음
  - 프로젝트 규모와 시간을 제대로 산정하지 못함
    - 얼마나 시간이 걸릴지 제대로 계산하지 못했음
- **해결 방법**:
  - 시간 제약을 인식한 뒤, 꼭 필요한 기능만 남기고 범위를 줄임
  - 전투 전용 UI는 포기하고, 맵 위에서 로그로 전투 결과만 표시하는 방식으로 단순화
- **결과**: 프로젝트를 완성도 있게 마무리할 수 있었지만, 초반 시간 낭비 발생
  - **초반 3일은 계획이 너무 커서 허비하다가**, 이후 범위를 줄여서 매우 간소화된 클론으로 수렴했음. 발표에서도 "처음 3일을 날려먹었다"고 말할 만한 구간임.

### 2. 코드 구조 정리 부족

- **부족한 점**: 후반부에 한 파일(BattleLevel.cpp)에 로직이 집중됨
- **이유**:
  - 빠른 개발을 위해 기능 추가에 집중
    - 기능을 빨리 만들려고 하다 보니 코드 구조를 신경 쓰지 못했음
  - 리팩터링 시간을 할애하지 못함
    - 기능을 다 만드는 게 급해서 코드 정리할 시간이 없었음
- **해결 방법**:
  - 기능별로 함수는 나눴으나, 클래스 단위 분리는 하지 못함
  - 코드 정리 대신 DEBUG.md·Contexts.md 등 문서로 구조와 흐름을 정리해 두어 보완
- **결과**: 유지보수는 가능하지만, 코드 가독성과 확장성에 아쉬움
  - 지금은 동작하지만, 나중에 기능을 추가하려면 한 파일을 계속 수정해야 함

### 3. ASCII 아트 미적용

- **부족한 점**: 텍스트 위주 표현으로 시각적 완성도 부족
- **이유**:
  - 시간 부족으로 시각 연출에 투자하지 못함
    - 기능 구현에 시간을 다 써서 시각적 표현까지 신경 쓸 여유가 없었음
  - 기능 구현에 집중
    - 게임이 돌아가는 게 우선이었음
- **해결 방법**:
  - 2x2 멀티라인으로 타일·영역 구분만 해서 최소한의 시각적 구분 확보
  - ASCII 아트·연출은 시간이 허락하지 않아 보류하고, 이후 보완 항목으로 남겨둠
- **결과**: 게임은 동작하지만 시각적 매력은 부족
  - 기능적으로는 문제없지만, 보기에는 좀 밋밋함

### 4. 테스트 부족

- **부족한 점**: 일부 엣지 케이스에서 버그 발생 (게임 종료 시 크래시 등)
- **이유**:
  - 개발 시간에 집중하여 테스트 시간 부족
    - 기능을 만드는 데 시간을 다 써서 테스트할 시간이 없었음
  - 수동 테스트만 수행
    - 자동화된 테스트는 없고, 직접 플레이하면서 확인함
- **해결 방법**:
  - 버그가 나올 때마다 DEBUG.md에 원인·해결 과정을 기록하고, 같은 유형은 문서를 참고해 해결
  - 메모리 누수는 Visual Studio CRT 디버그 힙으로 원인을 찾은 뒤, 재사용 버퍼 등으로 수정
- **결과**: 주요 버그는 해결했지만, 일부 엣지 케이스는 미발견 가능성
  - 자주 발생하는 버그는 다 고쳤지만, 특이한 상황에서 발생하는 버그는 놓쳤을 수 있음

## 직면한 문제와 해결 방법

### 1. 댕글링 포인터 문제 (이벤트 로그, 유닛 번호, 스탯 패널) — 렌더 깨짐(메모리 로드 문제)

- **문제**: Submit 시점과 실제 그리기 시점의 분리로 인한 메모리 수명 문제
  - 렌더러는 "이 주소에 있는 문자열을 나중에 그려줘"라고만 기억하는데, 그 주소에 있는 문자열이 사라져버림
  - 그 결과 화면에 텍스트가 깨지거나 쓰레기 값이 보이는 **렌더 깨짐**으로 나타남. 개발 중 가장 어려웠던 부분 중 하나였음.
- **해결**:
  - 임시 변수 대신 멤버 변수나 벡터 등 오래 사는 저장소 사용
    - 함수 안에서 만든 임시 변수 대신, 객체의 멤버 변수나 벡터에 저장해둠
  - `wrappedLogLines` 벡터, `unitNumberDisplay` 멤버, `uiBuffers` 멤버 배열 활용
    - 각각의 경우에 맞는 오래 사는 저장소를 사용함
- **학습**: 포인터 기반 시스템에서 메모리 수명 관리의 중요성
  - 포인터를 넘길 때는 "그 포인터가 가리키는 메모리가 언제까지 살아있는지"를 항상 생각해야 함

### 2. 게임 종료 시 크래시

- **문제**: `TriggerGameOver()`에서 포인터를 `nullptr`로 만든 뒤, 호출한 쪽에서 여전히 사용
  - 게임이 끝나면 포인터를 초기화하는데, 그 포인터를 아직 사용하려고 해서 크래시
- **해결**:
  - `PerformCombat()` 호출 직후 `if (gameOver) return;` 체크 추가
    - 전투 후에 게임이 끝났는지 확인하고, 끝났으면 더 이상 진행하지 않음
  - 게임 종료 시 포인터를 사용하는 모든 코드 경로에 안전 처리
    - 포인터를 사용하기 전에 항상 게임이 끝났는지 확인함
- **학습**: 상태 전환 시 포인터 무효화를 고려한 안전한 코드 작성
  - 상태가 바뀔 때는 "이전 상태에서 사용하던 것들이 이제 유효한지"를 항상 확인해야 함

### 3. 좌표 변환 시스템

- **문제**: 2x2 멀티라인 렌더링으로 인한 그리드 좌표와 화면 좌표의 불일치
  - 그리드 좌표는 (0, 0)부터 시작하는 논리적 좌표인데, 화면 좌표는 실제 픽셀 위치
  - 2x2로 렌더링하니까 변환이 복잡해짐
- **해결**:
  - 맵 렌더링: `baseX = x * 2 + 1`, `baseY = y * 2 + 1`
    - 그리드 좌표를 화면 좌표로 변환할 때 2배로 확대하고 +1
  - 마우스 클릭: `gridX = (mousePos.x - 1) / 2`, `gridY = (mousePos.y - 1) / 2`
    - 화면 좌표를 그리드 좌표로 변환할 때 -1 하고 2로 나눔
  - UI 여백 1칸 확보를 고려한 계산
    - 맵 왼쪽에 1칸 여백을 두기 위해 +1을 함
- **학습**: 논리적 좌표와 물리적 좌표의 매핑 설계
  - 논리적 좌표(게임 내부에서 사용)와 물리적 좌표(화면에 표시)를 어떻게 변환할지 설계가 중요함

### 4. 메모리 누수

- **문제**: 프레임이 반복될수록 메모리 사용량 증가
  - 게임을 오래 하면 메모리를 계속 먹어서 느려짐
- **해결**:
  - Visual Studio CRT 디버그 힙으로 원인 파악
    - 프로그램이 끝날 때 메모리 누수를 자동으로 찾아줌
  - `Renderer::Draw()`의 wchar 변환 버퍼를 재사용 버퍼로 변경
    - 매번 새로 만들지 않고 한 번 만든 버퍼를 재사용함
  - 명령당 할당 제거로 성능도 개선
    - 메모리 할당/해제가 줄어서 성능도 좋아짐
- **학습**: 동적 할당을 최소화하고 재사용 버퍼 활용
  - 매번 새로 만들지 말고, 한 번 만든 걸 재사용하는 게 효율적임

### 5. 맵 배경 타일 누수 (시행착오)

- **문제**: 로그 패널 오른쪽에 회색 타일이 비치거나 깜박임
  - 로그 패널 오른쪽에 맵 배경색이 보이는 현상
- **시도**: 로그 패널 여백을 검정 공백으로 채우는 방식 → "EVENT LOG" 잘림 버그 발생
  - 로그 텍스트가 없는 부분을 검정 공백으로 채우려고 했는데, 실수로 다른 문자열을 덮어써버림
- **최종 해결**: 맵/이동 범위를 UI 영역에 그리지 않도록 클리핑
  - 맵을 그릴 때 UI 영역에는 아예 그리지 않도록 함
- **학습**: 문제 해결 시 부작용을 고려하고, 더 안전한 방법을 선택
  - 문제를 해결하려고 할 때, 다른 곳에 문제가 생기지 않는지 항상 확인해야 함

## 다음 프로젝트에서 개선하거나 새롭게 시도해보고 싶은 점과 그 이유

### 1. 초기 설계 단계에서의 범위 명확화

- **시도하고 싶은 점**: 프로젝트 시작 전에 MVP(Minimum Viable Product)를 명확히 정의
- **이유**:
  - 초반 계획이 너무 커서 시간 낭비 발생
    - 처음에 계획을 너무 크게 잡아서 시간을 낭비했음
  - 핵심 기능에 집중하여 완성도 높은 결과물 제작 가능
    - 꼭 필요한 기능만 먼저 만들고, 나머지는 나중에 추가하는 게 나음
- **방법**: 기능 우선순위를 정하고, 필수 기능만 먼저 구현한 후 점진적 확장
  - "이 기능 없으면 게임이 안 돌아간다"는 것만 먼저 만들고, 나머지는 시간이 남으면 추가

### 2. 테스트 주도 개발 (TDD) 또는 체계적인 테스트

- **시도하고 싶은 점**: 주요 기능 구현 시 단위 테스트 작성
- **이유**:
  - 엣지 케이스에서 버그 발생 (게임 종료 시 크래시 등)
    - 특이한 상황에서 버그가 생겼는데, 미리 테스트해봤으면 발견했을 것
  - 수동 테스트만으로는 모든 케이스 커버 어려움
    - 직접 플레이하면서 테스트하는 것만으로는 모든 경우를 다 확인하기 어려움
- **방법**:
  - A* 알고리즘, 전투 시스템 등 핵심 로직에 단위 테스트 추가
    - 중요한 알고리즘이나 로직은 테스트 코드를 작성해서 검증
  - 통합 테스트로 게임 플레이 시나리오 검증
    - 실제 게임 플레이와 비슷한 상황을 만들어서 테스트

### 3. 코드 리팩터링 시간 확보

- **시도하고 싶은 점**: 기능 구현과 병행하여 주기적인 리팩터링
- **이유**:
  - 후반부에 한 파일에 로직이 집중되어 유지보수 어려움
    - BattleLevel.cpp에 모든 게 다 있어서 나중에 수정하기 어려움
  - 코드 가독성과 확장성 향상 필요
    - 코드가 정리되어 있으면 나중에 기능을 추가하기 쉬움
- **방법**:
  - 기능별로 클래스 분리 (예: CombatSystem, TurnManager 등)
    - 전투 관련 로직은 CombatSystem으로, 턴 관련 로직은 TurnManager로 분리
  - 매일 또는 매주 리팩터링 시간 확보
    - 기능을 만들 때마다 조금씩 정리하는 습관을 들임

### 4. 시각적 완성도 향상

- **시도하고 싶은 점**: ASCII 아트를 활용한 더 풍부한 시각 표현
- **이유**:
  - 텍스트 위주 표현으로 시각적 매력 부족
    - 지금은 텍스트만 있어서 보기 좀 밋밋함
  - 사용자 경험 개선 필요
    - 보기 좋으면 게임이 더 재미있음
- **방법**:
  - 박스 문자, 기호 등을 활용한 타일/유닛 표현
    - 특수 문자를 사용해서 더 예쁘게 표현
  - 애니메이션 효과 추가 (이동, 전투 등)
    - 유닛이 움직일 때나 전투할 때 시각적 효과 추가

### 5. 성능 프로파일링 및 최적화

- **시도하고 싶은 점**: 프로파일링 도구를 활용한 성능 분석
- **이유**:
  - 현재는 큰 문제가 없지만, 대규모 맵이나 많은 유닛에서 성능 이슈 가능성
    - 지금은 맵이 작고 유닛이 적어서 문제없지만, 나중에 커지면 느려질 수 있음
  - 최적화 여지 파악 필요
    - 어디가 느린지 알아야 최적화할 수 있음
- **방법**:
  - Visual Studio 프로파일러 활용
    - 어디서 시간을 많이 쓰는지 자동으로 찾아줌
  - 병목 지점 식별 후 최적화
    - 느린 부분을 찾아서 개선

### 6. 버전 관리 및 브랜치 전략

- **시도하고 싶은 점**: Git 브랜치 전략 명확화 (feature, bugfix 등)
- **이유**:
  - 기능 추가와 버그 수정이 섞여 추적 어려움
    - 어떤 변경이 언제 왜 생겼는지 추적하기 어려움
  - 롤백이나 특정 기능만 제거하기 어려움
    - 문제가 생겼을 때 되돌리기 어려움
- **방법**:
  - feature 브랜치로 기능별 개발
    - 새 기능을 만들 때는 별도 브랜치에서 작업
  - bugfix 브랜치로 버그 수정 분리
    - 버그를 고칠 때도 별도 브랜치에서 작업

### 7. 사용자 피드백 수집

- **시도하고 싶은 점**: 알파/베타 테스트 단계에서 사용자 피드백 수집
- **이유**:
  - 개발자 관점에서 놓친 UX 문제 발견 가능
    - 내가 만든 게임이라서 당연하다고 생각하는 부분이 사용자에게는 어려울 수 있음
  - 게임 밸런스 조정에 도움
    - 유닛이 너무 강하거나 약한지, 게임이 너무 쉬우거나 어려운지 알 수 있음
- **방법**:
  - 테스터 그룹 구성
    - 몇 명에게 게임을 해보게 하고 피드백 받음
  - 피드백 양식 작성 및 수집
    - 어떤 부분이 좋았는지, 어떤 부분이 불편했는지 체계적으로 수집

## 전체적인 평가

이 프로젝트를 통해 게임 개발의 전반적인 프로세스를 경험했음. 특히 메모리 관리, 좌표 변환, 알고리즘 구현 등 기술적 난제를 해결하며 많은 것을 배웠음. 문서화를 통해 지식을 체계적으로 정리한 것도 큰 성과임.

### 완성도 자체 평가: 6/10

- **전투 UI 미구현**: 원작처럼 별도 전투 화면·연출을 만들지 못하고 맵 위 로그로만 전투 결과를 표시함. 이 부분에서 **-1점**.
- **한 파일에 로직 집중**: 초반에는 신중히 나누다가, 후반에는 빠른 구현을 위해 BattleLevel 한 파일에 로직이 몰림. 가독성·확장성 측면에서 **-1점**.
- **ASCII 아트 미적용**: 텍스트 위주 표현으로만 구현하고, 박스 문자·기호 등을 활용한 시각적 완성도를 높이지 못함. **-1점**.
- **계획 과다·시간 허비**: 처음에 원작에 가깝게 만들려다 보니 계획이 너무 커졌고, 초반 3일을 날리다가 결국 "맵만 제대로 구현하고 전투 UI는 포기"하는 쪽으로 줄여야 했음. 매우 간소화된 클론으로 수렴한 점에서 **-1점**.

위 네 가지를 반영해 **6점**으로 평가함. 핵심 기능(맵, 이동, 지형 비용, 턴제 전투, 적 AI, 종료 조건)은 구현했지만, 시각적 완성도·코드 구조·범위 산정 측면에서 아쉬움이 있음. 제한된 시간 안에 "돌아가는 턴제 전술 게임"을 만든 것에는 만족함.

### 보완할 점 (향후 계획)

이후에라도 기존 클론의 기능을 더 구현하고, 마지막에는 ASCII 아트까지 적용해서 완성형에 가깝게 만들어 보고 싶음. 전투 전용 UI, 원거리/마법, 무기 시스템 등은 시간이 허락하는 범위에서 단계적으로 추가하는 것을 목표로 함.

다음 프로젝트에서는 초기 설계 단계에서의 범위 명확화(MVP 정의), 테스트 주도 개발, 주기적인 리팩터링 등을 통해 더 완성도 높은 결과물을 만들고 싶음.
